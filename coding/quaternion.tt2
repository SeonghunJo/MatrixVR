//------------------------------------------------------------------------------
using System;
using UnityEngine.Internal;
namespace UnityEngine
{
	public struct Quaternion
	{
		//
		// Static Fields
		//
		public const float kEpsilon = 1E-06f;
		
		//
		// Fields
		//
		public float z;
		
		public float w;
		
		public float x;
		
		public float y;
		
		//
		// Static Properties
		//
		public static Quaternion identity
		{
			get
			{
				return new Quaternion (0f, 0f, 0f, 1f);
			}
		}
		
		//
		// Properties
		//
		public Vector3 eulerAngles
		{
			get
			{
				return Quaternion.Internal_ToEulerRad (this) * 57.29578f;
			}
			set
			{
				this = Quaternion.Internal_FromEulerRad (value * 0.0174532924f);
			}
		}
		
		//
		// Indexer
		//
		public float this [int index]
		{
			get
			{
				switch (index)
				{
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				case 3:
					return this.w;
				default:
					throw new IndexOutOfRangeException ("Invalid Quaternion index!");
				}
			}
			set
			{
				switch (index)
				{
				case 0:
					this.x = value;
					break;
				case 1:
					this.y = value;
					break;
				case 2:
					this.z = value;
					break;
				case 3:
					this.w = value;
					break;
				default:
					throw new IndexOutOfRangeException ("Invalid Quaternion index!");
				}
			}
		}
		
		//
		// Constructors
		//
		public Quaternion (float x, float y, float z, float w)
		{
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}
		
		//
		// Static Methods
		//
		public static float Angle (Quaternion a, Quaternion b)
		{
			float f = Quaternion.Dot (a, b);
			return Mathf.Acos (Mathf.Min (Mathf.Abs (f), 1f)) * 2f * 57.29578f;
		}
		
		public static Quaternion AngleAxis (float angle, Vector3 axis)
		{
			return Quaternion.INTERNAL_CALL_AngleAxis (angle, ref axis);
		}
		
		[Obsolete ("Use Quaternion.AngleAxis instead. This function was deprecated because it uses radians instead of degrees")]
		public static Quaternion AxisAngle (Vector3 axis, float angle)
		{
			return Quaternion.INTERNAL_CALL_AxisAngle (ref axis, angle);
		}
		
		public static float Dot (Quaternion a, Quaternion b)
		{
			return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
		}
		
		public static Quaternion Euler (float x, float y, float z)
		{
			return Quaternion.Internal_FromEulerRad (new Vector3 (x, y, z) * 0.0174532924f);
		}
		
		public static Quaternion Euler (Vector3 euler)
		{
			return Quaternion.Internal_FromEulerRad (euler * 0.0174532924f);
		}
		
		[Obsolete ("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees")]
		public static Quaternion EulerAngles (Vector3 euler)
		{
			return Quaternion.Internal_FromEulerRad (euler);
		}
		
		[Obsolete ("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees")]
		public static Quaternion EulerAngles (float x, float y, float z)
		{
			return Quaternion.Internal_FromEulerRad (new Vector3 (x, y, z));
		}
		
		[Obsolete ("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees")]
		public static Quaternion EulerRotation (Vector3 euler)
		{
			return Quaternion.Internal_FromEulerRad (euler);
		}
		
		[Obsolete ("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees")]
		public static Quaternion EulerRotation (float x, float y, float z)
		{
			return Quaternion.Internal_FromEulerRad (new Vector3 (x, y, z));
		}
		
		public static Quaternion FromToRotation (Vector3 fromDirection, Vector3 toDirection)
		{
			return Quaternion.INTERNAL_CALL_FromToRotation (ref fromDirection, ref toDirection);
		}
		
		public static Quaternion Inverse (Quaternion rotation)
		{
			return Quaternion.INTERNAL_CALL_Inverse (ref rotation);
		}
		
		public static Quaternion Lerp (Quaternion from, Quaternion to, float t)
		{
			return Quaternion.INTERNAL_CALL_Lerp (ref from, ref to, t);
		}
		
		public static Quaternion LookRotation (Vector3 forward, [DefaultValue ("Vector3.up")] Vector3 upwards)
		{
			return Quaternion.INTERNAL_CALL_LookRotation (ref forward, ref upwards);
		}
		
		[ExcludeFromDocs]
		public static Quaternion LookRotation (Vector3 forward)
		{
			Vector3 up = Vector3.up;
			return Quaternion.INTERNAL_CALL_LookRotation (ref forward, ref up);
		}
		
		public static Quaternion RotateTowards (Quaternion from, Quaternion to, float maxDegreesDelta)
		{
			float num = Quaternion.Angle (from, to);
			if (num == 0f)
			{
				return to;
			}
			float t = Mathf.Min (1f, maxDegreesDelta / num);
			return Quaternion.UnclampedSlerp (from, to, t);
		}
		
		public static Quaternion Slerp (Quaternion from, Quaternion to, float t)
		{
			return Quaternion.INTERNAL_CALL_Slerp (ref from, ref to, t);
		}
		
		[Obsolete ("Use Quaternion.eulerAngles instead. This function was deprecated because it uses radians instead of degrees")]
		public static Vector3 ToEulerAngles (Quaternion rotation)
		{
			return Quaternion.Internal_ToEulerRad (rotation);
		}
		
		//
		// Methods
		//
		public override bool Equals (object other)
		{
			if (!(other is Quaternion))
			{
				return false;
			}
			Quaternion quaternion = (Quaternion)other;
			return this.x.Equals (quaternion.x) && this.y.Equals (quaternion.y) && this.z.Equals (quaternion.z) && this.w.Equals (quaternion.w);
		}
		
		public override int GetHashCode ()
		{
			return this.x.GetHashCode () ^ this.y.GetHashCode () << 2 ^ this.z.GetHashCode () >> 2 ^ this.w.GetHashCode () >> 1;
		}
		
		public void Set (float new_x, float new_y, float new_z, float new_w)
		{
			this.x = new_x;
			this.y = new_y;
			this.z = new_z;
			this.w = new_w;
		}
		
		[Obsolete ("Use Quaternion.AngleAxis instead. This function was deprecated because it uses radians instead of degrees")]
		public void SetAxisAngle (Vector3 axis, float angle)
		{
			this = Quaternion.AxisAngle (axis, angle);
		}
		
		[Obsolete ("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees")]
		public void SetEulerAngles (Vector3 euler)
		{
			this = Quaternion.EulerRotation (euler);
		}
		
		[Obsolete ("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees")]
		public void SetEulerAngles (float x, float y, float z)
		{
			this.SetEulerRotation (new Vector3 (x, y, z));
		}
		
		[Obsolete ("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees")]
		public void SetEulerRotation (float x, float y, float z)
		{
			this = Quaternion.Internal_FromEulerRad (new Vector3 (x, y, z));
		}
		
		[Obsolete ("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees")]
		public void SetEulerRotation (Vector3 euler)
		{
			this = Quaternion.Internal_FromEulerRad (euler);
		}
		
		public void SetFromToRotation (Vector3 fromDirection, Vector3 toDirection)
		{
			this = Quaternion.FromToRotation (fromDirection, toDirection);
		}
		
		public void SetLookRotation (Vector3 view, [DefaultValue ("Vector3.up")] Vector3 up)
		{
			this = Quaternion.LookRotation (view, up);
		}
		
		[ExcludeFromDocs]
		public void SetLookRotation (Vector3 view)
		{
			Vector3 up = Vector3.up;
			this.SetLookRotation (view, up);
		}
		
		public void ToAngleAxis (out float angle, out Vector3 axis)
		{
			Quaternion.Internal_ToAxisAngleRad (this, out axis, out angle);
			angle *= 57.29578f;
		}
		
		[Obsolete ("Use Quaternion.ToAngleAxis instead. This function was deprecated because it uses radians instead of degrees")]
		public void ToAxisAngle (out Vector3 axis, out float angle)
		{
			Quaternion.Internal_ToAxisAngleRad (this, out axis, out angle);
		}
		
		[Obsolete ("Use Quaternion.eulerAngles instead. This function was deprecated because it uses radians instead of degrees")]
		public Vector3 ToEuler ()
		{
			return Quaternion.Internal_ToEulerRad (this);
		}
		
		[Obsolete ("Use Quaternion.eulerAngles instead. This function was deprecated because it uses radians instead of degrees")]
		public Vector3 ToEulerAngles ()
		{
			return Quaternion.Internal_ToEulerRad (this);
		}
		
		public override string ToString ()
		{
			return UnityString.Format ("({0:F1}, {1:F1}, {2:F1}, {3:F1})", new object[]
			                           {
				this.x,
				this.y,
				this.z,
				this.w
			});
		}
		
		public string ToString (string format)
		{
			return UnityString.Format ("({0}, {1}, {2}, {3})", new object[]
			                           {
				this.x.ToString (format),
				this.y.ToString (format),
				this.z.ToString (format),
				this.w.ToString (format)
			});
		}
		
		//
		// Operators
		//
		public static bool operator == (Quaternion lhs, Quaternion rhs)
		{
			return Quaternion.Dot (lhs, rhs) > 0.999999f;
		}
		
		public static bool operator != (Quaternion lhs, Quaternion rhs)
		{
			return Quaternion.Dot (lhs, rhs) <= 0.999999f;
		}
		
		public static Quaternion operator * (Quaternion lhs, Quaternion rhs)
		{
			return new Quaternion (lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y, lhs.w * rhs.y + lhs.y * rhs.w + lhs.z * rhs.x - lhs.x * rhs.z, lhs.w * rhs.z + lhs.z * rhs.w + lhs.x * rhs.y - lhs.y * rhs.x, lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z);
		}
		
		public static Vector3 operator * (Quaternion rotation, Vector3 point)
		{
			float num = rotation.x * 2f;
			float num2 = rotation.y * 2f;
			float num3 = rotation.z * 2f;
			float num4 = rotation.x * num;
			float num5 = rotation.y * num2;
			float num6 = rotation.z * num3;
			float num7 = rotation.x * num2;
			float num8 = rotation.x * num3;
			float num9 = rotation.y * num3;
			float num10 = rotation.w * num;
			float num11 = rotation.w * num2;
			float num12 = rotation.w * num3;
			Vector3 result;
			result.x = (1f - (num5 + num6)) * point.x + (num7 - num12) * point.y + (num8 + num11) * point.z;
			result.y = (num7 + num12) * point.x + (1f - (num4 + num6)) * point.y + (num9 - num10) * point.z;
			result.z = (num8 - num11) * point.x + (num9 + num10) * point.y + (1f - (num4 + num5)) * point.z;
			return result;
		}
	}
}